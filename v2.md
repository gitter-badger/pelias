I'd like to bring our internal @mapzen discussions about the API design out in to the public, so anyone who is interested can contribute ideas and add their input.

#### current API

We currently have the following [API endpoints](https://github.com/pelias/pelias):

- `/suggest`
- `/search`
- `/reverse`

Having a bit of time to retrospect, the current API has a few flaws which need to be addressed:

#### issues

- There is no way to address and retrieve a single resource by global id
- There is no way to address and retrieve multiple resources by global ids
- There is no distinction between the `schema` of returned documents
- There is no easy way to filter the results or to customise the query on the client
- There are some inconsistencies in naming of parameters
- It is not very `RESTful`
- There is a huge amount of power which can be exposed to the client which is currently not

#### use-cases

Internally we have had some discussions about how to make an API which is easily consumable from mobile devices. This will always be a prime concern of Pelias as mobile apps are clearly here to stay and a major consumer of geocoding APIs due to their mobile nature and device capabilities.

However it's also important to consider some other common use-cases for the API, eg:

- Postcode (zip code) lookups in forms

![zip_lookup](./img/postcode_lookup.png)

- More general place lookups in forms

![location_lookup](./img/location_lookup.png)

- etc...

A simple search will yield more results such as: [Connecting the Dots: Why Geocoding is Critical for Businesses](https://www.melissadata.com/featurearticles/geocoding-is-critical-for-businesses.htm)

#### moving forward

It seems like we need to move away from this old schema as quickly as possible to a new API which can not only address the issues above but also set up an interface on which to build future iterations of the system.

#### to rest or not to rest?

REST has it's pros and it has it's cons; regardless, it's a language of interoperability which is well known and works well over HTTP/1.1.

In my mind REST has 2 constructs which make it quick-and-easy to consume:

- Idempotent URLs, hit the same URL twice, you get the same thing.
- The concept of a `resource`, when you address a resource by name, you get back documents of **only** that schema.

Neither of these 2 concepts are addressed in the current API.

#### v2 proposal

So, in order to address the issues noted above, I'm offering the following draft of a v2 spec:

###### 1. Single item retrieval

You can address resources by `type` and `id`.

```GET /geoname/geoname:11232```

###### 2. Collection filtering

You can filter a collection of resources by arbitrary criteria.

```GET /geoname?id=geoname11223:&id=geoname:231445```

###### 3. UID/ID inference

You can omit the `type` when addressing a single collection.

```GET /geoname/11232```

###### 4. Addressing multiple collections

You can target multiple collections of the same underlying schema.

```GET /geoname,osmnode,osmway?id=geoname:11223,osmnode:11123```

###### 5. Collection specific fulltext search

You can also search on one or more collections using the same collection filtering endpoint.

```GET /geoname,osmnode,osmway?search=pizza hut```

###### 6. Collection aliasing

Collection aliases are provided to group commonly associated `types`.

eg. `poi` expands to `geoname,osmnode,osmway`

```GET /poi?id=geoname:11223,osmnode:11123```
```GET /poi?search=empire state```
```GET /administrative?search=new york```

###### 7. Collection specific autocomlete

You can also autocomplete on one or more collections.

```GET /poi?prefix=empire s```
```GET /administrative?prefix=new y```
